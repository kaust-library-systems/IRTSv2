<?php

//Define function to generate Pure XML
function generatePureXML($source, $field, $value, $ownerID)
{
	global $irts, $report, $errors, $localPersonsScopusIDs;

	$idInIRTS = $field.'_'.$value;

	# get all known Scopus author IDs for local people
	$localPersonsScopusIDs = getValues($irts, "SELECT DISTINCT m2.value FROM `metadata` m 
		LEFT JOIN metadata m2 ON m.rowID = m2.parentRowID 
		LEFT JOIN metadata m3 ON m.rowID = m3.parentRowID 
		LEFT JOIN metadata m4 ON m3.rowID = m4.parentRowID 
		WHERE m.source = 'scopus' 
		AND m.field = 'dc.contributor.author' 
		AND m2.field = 'dc.identifier.scopusid' 
		AND m3.field = 'dc.contributor.affiliation' 
		AND m4.field = 'dc.identifier.scopusid' 
		AND m4.value = '60092945'", array('value'), 'arrayOfValues');

	//Set startTime for script
	$startTime=date("Y-m-d H:i:s");

	// enable user error handling (specifically for warnings generated by schema validation)
	libxml_use_internal_errors(true);

	$purexml = new SimpleXMLElement('<?xml version="1.0" encoding="UTF-8"?><v1:publications xmlns:v1="v1.publication-import.base-uk.pure.atira.dk" xmlns:v3="v3.commons.pure.atira.dk"/>');

	$includedIDs = array();
	$newIDs = array();
	$modifiedIDs = array();

	//Record count variable
	$recordTypeCounts = array('all'=>0,'new'=>0,'modified'=>0,'deleted'=>0,'skipped'=>0,'unchanged'=>0);

	if($source === 'scopus')
	{
		if($field === 'eid')
		{
			$recordTypeCounts['all']++;

			$itemReport = $recordTypeCounts['all'].') '.$value.PHP_EOL;

			$sourceData = retrieveScopusRecord('abstract', $field, $value);

			//Strip namespaces due to problems in accessing elements with namespaces even with xpath, temporary solution?
			$namespaces = array('dc','opensearch','prism','dn','ait','ce','cto','xocs');
			foreach($namespaces as $namespace)
			{
				$sourceData = str_replace('<'.$namespace.':', '<', $sourceData);

				$sourceData = str_replace('</'.$namespace.':', '</', $sourceData);
			}

			$sourceData = simplexml_load_string($sourceData);

			//remove bibliography from saved and processed record
			unset($sourceData->item->bibrecord->tail);

			$record = processScopusRecord($sourceData);

			$entry = preparePureRecord($record, $purexml, $value, $ownerID);

			$output = $entry['output']->asXML();

			$recordType = saveSourceData($report, 'forPure_scopusExport', $value, $output, 'XML');

			$xml = new DOMDocument();
			$xml->loadXML('<?xml version="1.0" encoding="UTF-8"?>
		<v1:publications xmlns:v1="v1.publication-import.base-uk.pure.atira.dk" xmlns:v3="v3.commons.pure.atira.dk">'.$output.'</v1:publications>');

			if($xml->schemaValidate('/var/www/irts/public_html/xsd/forPure/publication.xsd'))
			{
				$itemReport .= '-- XML is valid'.PHP_EOL;
				$includedIDs[] = $idInSource;
			}
			else
			{
				$itemReport .= '-- XML is invalid against schema'.PHP_EOL;
				$errors[] = array('type'=>'XML validation','message'=>'XML for '.$idInSource.' is invalid against schema: '.print_r(libxml_get_errors(), TRUE));
			}
			//clear errors and warnings from schema validation
			libxml_clear_errors();
			
			//echo $itemReport;
			$report .= $itemReport;

			ob_flush();
			set_time_limit(0);
		}
		else
		{
			$results = call_user_func('query'.(ucfirst($source)), $field, $value, 0, 1);

			//Strip namespaces due to problems in accessing elements with namespaces even with xpath, temporary solution?
			$results = str_replace('dc:', '', $results);
			$results = str_replace('opensearch:', '', $results);
			$results = str_replace('prism:', '', $results);

			$results = simplexml_load_string($results);

			$total = (int)$results->totalResults;
			
			//echo $total.PHP_EOL;

			if($total !== 0)
			{
				//Checking the number of iterative queries that will be needed to harvest the full list 10 items at a time, helps avoid entering an endless loop when there are problems within the loop that prevent the item count from progressing
				$queryCount = 0;
				$queryMax = (int)ceil($total/10);
				
				while($recordTypeCounts['all'] < $total && $queryCount < $queryMax)
				{
					$queryCount++;
					
					$results = call_user_func('query'.(ucfirst($source)), $field, $value, $recordTypeCounts['all']);

					//Strip namespaces due to problems in accessing elements with namespaces even with xpath, temporary solution?
					$results = str_replace('dc:', '', $results);
					$results = str_replace('opensearch:', '', $results);
					$results = str_replace('prism:', '', $results);

					$results = simplexml_load_string($results);
					
					//echo $queryCount.') '.$results->totalResults.PHP_EOL;

					if((int)$results->totalResults !== 0)
					{
						foreach($results->entry as $item)
						{
							$recordTypeCounts['all']++;

							$eid = (string)$item->eid;
							
							//echo $recordTypeCounts['all'].') '.$eid.PHP_EOL;

							$itemReport = $recordTypeCounts['all'].') '.$eid.PHP_EOL;

							$sourceData = retrieveScopusRecord('abstract', 'eid', $eid);

							//Strip namespaces due to problems in accessing elements with namespaces even with xpath, temporary solution?
							$namespaces = array('dc','opensearch','prism','dn','ait','ce','cto','xocs');
							foreach($namespaces as $namespace)
							{
								$sourceData = str_replace('<'.$namespace.':', '<', $sourceData);

								$sourceData = str_replace('</'.$namespace.':', '</', $sourceData);
							}

							$sourceData = simplexml_load_string($sourceData);

							//remove bibliography from saved and processed record
							unset($sourceData->item->bibrecord->tail);

							$record = processScopusRecord($sourceData);

							$entry = preparePureRecord($record, $purexml, $value, $ownerID);

							$output = $entry['output']->asXML();

							$idInSource = $eid;

							$recordType = saveSourceData($report, 'forPure_scopusExport', $idInSource, $output, 'XML');

							$xml = new DOMDocument();
							$xml->loadXML('<?xml version="1.0" encoding="UTF-8"?>
						<v1:publications xmlns:v1="v1.publication-import.base-uk.pure.atira.dk" xmlns:v3="v3.commons.pure.atira.dk">'.$output.'</v1:publications>');

							if($xml->schemaValidate('/var/www/irts/public_html/xsd/forPure/publication.xsd'))
							{
								$itemReport .= '-- XML is valid'.PHP_EOL;
								//check for items with a conflicting repository record
								if(strpos($output, '<v1:url>http://hdl.handle.net/') !== FALSE)
								{
									$itemReport .= '- has conflicting record in repository'.PHP_EOL;
									$itemReport .= '-- removed from list of included IDs'.PHP_EOL;
								}
								else
								{
									$includedIDs[] = $idInSource;
									$newIDs[] = $idInSource;
								}
							}
							else
							{
								$itemReport .= '-- XML is invalid against schema'.PHP_EOL;
								$errors[] = array('type'=>'XML validation','message'=>'XML for '.$idInSource.' is invalid against schema: '.print_r(libxml_get_errors(), TRUE));
							}
							//clear errors and warnings from schema validation
							libxml_clear_errors();
							//echo $itemReport;
							$report .= $itemReport;
							sleep(1);
						}
						set_time_limit(0);
					}
					sleep(1);
				}
			}
		}
	}
	elseif($source === 'repository')
	{
		if(isset($_GET['handle']))
		{
			$results = array($_GET['handle']);
		}
		elseif(isset($_GET['special']))
		{
			//Use if you want query a specific subset of items with a more complex query
			$results = getValues($irts, "SELECT * FROM metadata WHERE source = 'repository'
				AND field = 'dc.identifier.uri' AND value IN ('http://hdl.handle.net/10754/625871')", array('idInSource'));
		}
		else
		{
			$results = getValues($irts, setSourceMetadataQuery($source, NULL, NULL, $field, $value), array('idInSource'));
		}

		$total = count($results);

		//Shorten the results list to generate a limited number of records for testing
		if(isset($_GET['limit']))
		{
			$results = array_slice($results, 0, $_GET['limit']);
		}

		$existingListID = $idInIRTS.'_All';

		$existingListJSON =  getValues($irts, "SELECT sourceData FROM `sourceData` 
			WHERE `source` = 'forPure_repositoryExport'  
			AND `idInSource` LIKE '$existingListID' 
			AND `format` = 'JSON'
			AND `deleted` IS NULL 
			ORDER BY `added` DESC 
			LIMIT 1", array('sourceData'), 'singleValue');

		//split the data
		$existing = json_decode($existingListJSON, TRUE);

		$new = getValues($irts, "SELECT idInSource FROM `metadata` 
			WHERE `source` LIKE 'repository' 
			AND `field` LIKE 'dc.date.accessioned' 
			AND (`value` LIKE '".YESTERDAY."%' OR `value` LIKE '".TODAY."%') 
			AND `deleted` IS NULL", array('idInSource'));

		$modified = getValues($irts, "SELECT idInSource FROM `metadata` 
			WHERE `source` LIKE 'repository' 
			AND `field` LIKE 'dspace.date.modified' 
			AND (`value` LIKE '".YESTERDAY."%' OR `value` LIKE '".TODAY."%') 
			AND `deleted` IS NULL 
			AND idInSource NOT IN (
				SELECT idInSource FROM `metadata` 
				WHERE `source` LIKE 'repository' 
				AND `field` LIKE 'dc.date.accessioned' 
				AND (`value` LIKE '".YESTERDAY."%' OR `value` LIKE '".TODAY."%') 
				AND `deleted` IS NULL)", array('idInSource'));

		$template = '';

		$template = prepareTemplate($value);

		//print_r($template);
		
		$includedIDs = $existing;

		foreach($results as $handle)
		{
			$generate = FALSE;

			if(isset($_GET['regenerate']))
			{
				$regenerate = $_GET['regenerate'];
			}
			else
			{
				$regenerate = 'newAndModified';
			}

			if(in_array($handle, $new))
			{
				if($regenerate === 'new'||$regenerate === 'newAndModified')
				{
					$generate = TRUE;
				}
			}

			if(in_array($handle, $modified))
			{
				if($regenerate === 'modified'||$regenerate === 'newAndModified')
				{
					$generate = TRUE;
				}
			}

			if($regenerate === 'all')
			{
				$generate = TRUE;
			}

			if(!in_array($handle, $existing))
			{
				$generate = TRUE;
			}

			if($generate)
			{
				$type = getValues($irts, setSourceMetadataQuery($source, $handle, NULL, 'dc.type'), array('value'), 'singleValue');
				
				$recordTypeCounts['all']++;
				
				$record = getRecord($source, $handle, $template);
			
				$itemReport = $recordTypeCounts['all'].') '.$handle.PHP_EOL;
				
				if(isset($_GET['flag']))
				{
					if($_GET['flag'] === 'printRecord')
					{
						print_r($record).PHP_EOL;
					}
				}

				//the $value (type for repository records) is sent here in the place where the authorID is sent for Scopus records, it is OK in that it will not match a Scopus authorID and so does not create a problem, setting it as NULL may create a problem as it may match cases where the Scopus authorID is NULL...
				$entry = preparePureRecord($record, $purexml, $value, $ownerID);

				if(!is_null($entry['output']))
				{
					$output = $entry['output']->asXML();

					$recordType = saveSourceData($report, 'forPure_repositoryExport', $handle, $output, 'XML');
				}

				//echo $itemReport;
				$report .= $itemReport;

				//Add to new or modified list based on whether XML is new or modified
				if($recordType === 'new')
				{
					$new[] = $handle;
				}

				if($recordType === 'modified')
				{
					$modified[] = $handle;
				}

				//retrieve just saved (or previously existing) XML to test validity
				$itemxml = trim(getValues($irts, "SELECT `sourceData` FROM `sourceData` 
					WHERE `source` = 'forPure_repositoryExport' 
					AND `idInSource` LIKE '$handle' 
					AND `format` = 'XML'
					AND `deleted` IS NULL", array('sourceData'), 'singleValue'));

				$xml = new DOMDocument();

				if(in_array($type, array('Thesis', 'Dissertation')))
				{
					$xml->loadXML('<?xml version="1.0" encoding="UTF-8"?>
				<v1:studentTheses xmlns:v1="v1.studentthesis-sync.pure.atira.dk" xmlns:v3="v3.commons.pure.atira.dk">'.$itemxml.'</v1:studentTheses>');

					$schema = '/var/www/irts/public_html/xsd/forPure/studentthesis.xsd';
				}
				elseif(in_array($type, array('Bioproject','Dataset')))
				{
					$xml->loadXML('<?xml version="1.0" encoding="UTF-8"?>
				<v1:datasets xmlns:v1="v1.dataset.pure.atira.dk" xmlns:v3="v3.commons.pure.atira.dk">'.$itemxml.'</v1:datasets>');

					$schema = '/var/www/irts/public_html/xsd/forPure/dataset.xsd';
				}
				else
				{
					$xml->loadXML('<?xml version="1.0" encoding="UTF-8"?>
				<v1:publications xmlns:v1="v1.publication-import.base-uk.pure.atira.dk" xmlns:v3="v3.commons.pure.atira.dk">'.$itemxml.'</v1:publications>');

					$schema = '/var/www/irts/public_html/xsd/forPure/publication.xsd';
				}

				if($xml->schemaValidate($schema))
				{
					//$itemReport .= '-- XML is valid'.PHP_EOL;
					$includedIDs[] = $handle;

					if(in_array($handle,$new))
					{
						$newIDs[] = $handle;
					}

					if(in_array($handle,$modified))
					{
						$modifiedIDs[] = $handle;
					}
				}
				else
				{
					//remove from array of IDs if previously valid item now has an invalid record
					if(in_array($handle, $includedIDs))
					{
						$key = array_search($handle, $includedIDs);
						
						unset($includedIDs[$key]);
					}
					
					//$itemReport .= '-- XML is invalid against schema'.PHP_EOL;
					$errors[] = array('type'=>'XML validation','message'=>'XML for '.$handle.' is invalid against '.$schema.' : '.print_r(libxml_get_errors(), TRUE));
				}

				//clear errors and warnings from schema validations
				libxml_clear_errors();
				
				echo $itemReport;
				$report .= $itemReport;

				ob_flush();
				set_time_limit(0);
			}
		}
		$includedIDs = array_unique($includedIDs);
	}

	//Set endTime for this item
	$endTime=date("Y-m-d H:i:s");

	$timeStart = new DateTime($startTime);
	$timeEnd = new DateTime($endTime);
	$timeElapsed = $timeStart->diff($timeEnd)->format("%H:%I:%S");

	$field = 'irts.process.timeElapsed';

	if($source === 'scopus')
	{
		$rowID = mapTransformSave('forPure_scopusExport', $idInIRTS, '', $field, '', 1, $timeElapsed, NULL);
		
		$recordType = saveSourceData($report, 'forPure_scopusExport', $idInIRTS, json_encode($includedIDs), 'JSON');

		if( $recordType == 'unchanged')
		{
			$irts->query("UPDATE `sourceData` SET `added`='".date("Y-m-d H:i:s")."' 
				WHERE `idInSource`='$idInIRTS' 
				AND `source`='forPure_scopusExport' 
				AND `deleted` IS NULL");
		}

		//return $includedIDs;
		return $newIDs;
	}
	elseif($source === 'repository')
	{
		$rowID = mapTransformSave('forPure_repositoryExport', $idInIRTS, '', $field, '', 1, $timeElapsed, NULL);
		
		$exports = array('All'=>$includedIDs,'New'=>$newIDs,'Modified'=>$modifiedIDs);

		foreach($exports as $exportType => $exportedIDs)
		{
			$entryID = $idInIRTS.'_'.$exportType;
			$recordType = saveSourceData($report, 'forPure_repositoryExport', $entryID, json_encode($exportedIDs), 'JSON');
			if( $recordType == 'unchanged')
			{
				$irts->query("UPDATE `sourceData` SET `added`='".date("Y-m-d H:i:s")."' 
					WHERE `idInSource`='$entryID' 
					AND `source`='forPure_repositoryExport' 
					AND `deleted` IS NULL");
			}
		}
		return $exports;
	}
}
